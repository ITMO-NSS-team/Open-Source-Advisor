The provided path: 'test_dir/'
File: api.py
----Class: Api, line 16

File: api_tables.py

File: c.py
----Class: MyClass, line 1
--------Method: method_one, Args: ['self', 'x'], Return: str, line 2
        Source:
    def method_one(self, x: int) -> str:
        return str(x)
--------Method: method_two, Args: ['self', 'y'], Return: None, line 5
        Source:
    def method_two(self, y):
        return y
----Function: standalone_function, Args: ['a', 'b'], Return: int, line 8
        Source:
    def standalone_function(a, b) -> int:
    return a + b

File: control.py
----Class: Control, line 4
--------Method: __init__, Args: ['self'], Return: None, line 5
        Source:
    def __init__(self):
        self.flag_game = True
        self.flag_direction = "RIGHT"
        self.flag_pause = True
--------Method: control, Args: ['self'], Return: None, line 10
        Source:
    def control(self):
        for event in pygame.event.get():
            if event.type == QUIT:
                self.flag_game = False
            elif event.type == KEYDOWN:
                if event.key == K_RIGHT and self.flag_direction != "LEFT":
                    self.flag_direction = "RIGHT"
                elif event.key == K_LEFT and self.flag_direction != "RIGHT":
                    self.flag_direction = "LEFT"
                elif event.key == K_DOWN and self.flag_direction != "UP":
                    self.flag_direction = "DOWN"
                elif event.key == K_UP and self.flag_direction != "DOWN":
                    self.flag_direction = "UP"
                elif event.key == K_x:
                    self.flag_game = False
                elif event.key == K_RETURN:
                    if self.flag_pause:
                        self.flag_pause = False
                    elif self.flag_pause == False:
                        self.flag_pause = True

File: d.py
----Function: foo, Args: [], Return: None, line 1
        Source:
    def foo():
    pass
----Function: bar, Args: ['x'], Return: None, line 4
        Source:
    def bar(x):
    return x

File: data_models.py

File: endpoint.py
----Class: Endpoint, line 14
--------Method: __init__, Args: ['self', 'url', 'param_names'], Return: None, line 15
        Source:
    def __init__(self, url: str, param_names: Collection[str] = None):
        if param_names is not None:
            param_names = tuple(param_names)
        self.url = url
        self.param_names = param_names
        self.url_params = (fname for _, fname, _, _ in Formatter().parse(self.url) if fname)
--------Method: _check_params, Args: ['self', 'params'], Return: None, line 22
        Docstring:
        """
        �� ��� ��������� ��� �������� �����������
        if extra_params:
            error_msg += f'\nUnexpected params: ({", ".join(extra_params)}).'
            is_error = True
        """
        Source:
    def _check_params(self, params: dict[str, Any]) -> None:
        if self.param_names is None:
            return

        missing_params = set(self.param_names).difference(set(params))
        extra_params = set(params).difference(set(self.param_names))

        error_msg = f"{self.__class__.__name__} {self.url}."
        is_error = False

        if missing_params:
            error_msg += f'\nMissing params: ({", ".join(missing_params)}).'
            is_error = True

        """
        �� ��� ��������� ��� �������� �����������
        if extra_params:
            error_msg += f'\nUnexpected params: ({", ".join(extra_params)}).'
            is_error = True
        """
        if is_error:
            raise ValueError(error_msg)

    def _parse_url_params(self, pa
--------Method: _parse_url_params, Args: ['self', 'params'], Return: None, line 45
        Source:
    
        url_params = {fname: params.pop(fname) for fname in self.url_params}
        url = self.url
        if url_params:
            url = self.url.format(**url_params)
        return url, params

    def __call__(self, json_data: 
--------Method: __call__, Args: ['self', 'json_data'], Return: ms), line 52
        Source:
     None = None, **params) -> Any:
        self._check_params(params)
        url, params = self._parse_url_params(params)
        result = self._execute_request(url, params=params, json_data=json_data)
        if result.status_code != 200:
            logger.error(f"url: {url}")
            logger.error(f"params: {params}")
            logger.error(f"json_data: {json_data}")
            raise RequestException(result.status_code)
        return result.json()

    @abc.abstractmethod
    def _e
--------Method: _execute_request, Args: ['url', 'params'], Return: mplementedError
, line 64
        Source:
    s: dict[str, Any]) -> requests.Request:
        raise NotImplementedError


class GetEndpoint(Endpoint):
    
----Class: GetEndpoint, line 68
--------Method: _execute_request, Args: ['self', 'url', 'params', 'json'], Return: quests.get(
     , line 69
        Source:
            url: str,
        params: dict[str, Any],
        json: dict | None = None,
    ) -> requests.Response:
        return requests.get(
            url,
            params=params,
            json=json,
            headers={"accept": "application/json"},
        )


class PostEndpoint(Endpoint):
   
----Class: PostEndpoint, line 83
--------Method: _execute_request, Args: ['self', 'url', 'params', 'json_data'], Return: quests.post(
    , line 84
        Source:
            url: str,
        params: dict[str, Any] | None = None,
        json_data: dict | None = None,
    ) -> requests.Response:
        return requests.post(
            url,
            params=params,
            json=json_data,
            headers={"accept": "application/json"},
        )


File: filter_and_impact_requests.py
----Function: parks_by_budget, Args: ['budget', 'territory_name'], Return: DataByBudget | NoContentMessage, line 7
    Docstring:
    """Getting parks that fit the given parameters

    Args:
        budget: sum in rubles
        territory_name: name of territory where to find parks;
            can be city, municipality or district

    Returns:
        Either a class containing information about parks and their locations, or a
        class with a message that no data is available
    """
        Source:
    def parks_by_budget(budget: int | None = None, territory_name: str | None = None) -> DataByBudget | NoContentMessage:
    """Getting parks that fit the given parameters

    Args:
        budget: sum in rubles
        territory_name: name of territory where to find parks;
            can be city, municipality or district

    Returns:
        Either a class containing information about parks and their locations, or a
        class with a message that no data is available
    """
    data = Api.EndpointsUrban.get_parks(budget=budget, territory_name=territory_name)
    if len(data.keys()) > 1:
        return DataByBudget.from_dict(data)
    else:
        return NoContentMessage.from_dict(data)
----Function: territory_by_budget, Args: ['budget', 'service_type', 'territory_name'], Return: DataByBudget | NoContentMessage, line 26
    Docstring:
    """Getting territory that fit the given parameters

    Args:
        budget: sum in rubles
        service_type: name of service to place;
            can be school, polyclinic, kindergarten or park
        territory_name: name of territory where to find parks;
            can be city, municipality or district

    Returns:
        Either a class containing information about potential areas for the location of
        new services, or a class with a message that no data is available
    """
        Source:
    def territory_by_budget(
    budget: int | None = None,
    service_type: str | None = None,
    territory_name: str | None = None,
) -> DataByBudget | NoContentMessage:
    """Getting territory that fit the given parameters

    Args:
        budget: sum in rubles
        service_type: name of service to place;
            can be school, polyclinic, kindergarten or park
        territory_name: name of territory where to find parks;
            can be city, municipality or district

    Returns:
        Either a class containing information about potential areas for the location of
        new services, or a class with a message that no data is available
    """
    if not all([service_type, territory_name]):
        raise ValueError("Type of service and territory name must be provided")

    data = Api.EndpointsUrban.get_territory_for_service(
        budget=budget, service_type=service_type, territory_name=territory_name
    )
    if len(data.keys()) > 1:
        return DataByBudget.from_dict(data)
    else:
        return NoContentMessage.from_dict(data)
----Function: impact_by_construction, Args: ['block_id', 'service_type', 'object_type', 'capacity'], Return: ImpactEvaluation, line 56
    Docstring:
    """Getting parks that fit the given parameters

    Args:
        block_id: identifier of the source block
        service_type: name of service to place;
            can be school, polyclinic, kindergarten
        object_type: selection of object for which the provision will be recalculated;
            can be service, house, apartment block, dwelling.
        capacity: new facility capacity

    Returns:
        A class containing information about changes from the construction of new
        services or a house
    """
        Source:
    def impact_by_construction(
    block_id: int | None = None,
    service_type: str | None = None,
    object_type: str | None = None,
    capacity: int | None = None,
) -> ImpactEvaluation:
    """Getting parks that fit the given parameters

    Args:
        block_id: identifier of the source block
        service_type: name of service to place;
            can be school, polyclinic, kindergarten
        object_type: selection of object for which the provision will be recalculated;
            can be service, house, apartment block, dwelling.
        capacity: new facility capacity

    Returns:
        A class containing information about changes from the construction of new
        services or a house
    """
    if not all([block_id, service_type, object_type, capacity]):
        raise ValueError("Block id, type of service, object type and capacity must be provided")
    data = Api.EndpointsUrban.get_impact(
        block_id=block_id,
        service_type=service_type,
        object_type=object_type,
        capacity=capacity,
    )
    return ImpactEvaluation.from_dict(data)

File: food.py
----Class: Food, line 4
--------Method: __init__, Args: ['self'], Return: None, line 5
        Source:
    def __init__(self):

        self.food_position = []
--------Method: get_food_position, Args: ['self', 'gui'], Return: None, line 9
        Source:
    def get_food_position(self,gui):
        #For getting random position for food
        self.food_position = random.choice(gui.field)
--------Method: draw_food, Args: ['self', 'window'], Return: None, line 13
        Source:
    def draw_food(self,window):
        #Draws food
        pygame.draw.rect(window, pygame.Color("Yellow"), pygame.Rect(self.food_position[0], self.food_position[1], 10, 10))

File: gui.py
----Class: Gui, line 3
--------Method: __init__, Args: ['self'], Return: None, line 4
        Source:
    def __init__(self):
        self.level = [
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                ]

        self.gui_image = pygame.image.load("images/gui.png")
        self.win = pygame.image.load("images/win.png")
        self.lose = pygame.image.load("images/lose.png")
        self.barrier = []
        self.field = []
        self.indicator = [[12,12]]
        self.game = "GAME"
--------Method: create_image, Args: ['self'], Return: None, line 61
        Source:
    def create_image(self):
        #creates image on list`s data
        screen = pygame.Surface((441,491),pygame.SRCALPHA,32)
        x = 1
        y = 1
        for i in self.level:
            if i == 0:
                pygame.draw.rect(screen, pygame.Color("Grey"), pygame.Rect(x,y,10,10))
            x += 11
            if x == 441:
                y += 11
                x = 1
        pygame.image.save(screen,"images/gui.png")
--------Method: draw_level, Args: ['self', 'window'], Return: None, line 75
        Source:
    def draw_level(self,window):
        #Level painting
        window.blit(self.gui_image, (0,0))
--------Method: init_field, Args: ['self'], Return: None, line 79
        Source:
    def init_field(self):
        #Fills lists with coordinates
        x = 1
        y = 1
        for i in self.level:
            if i == 0:
                self.barrier.append([x,y])
            elif i == 1 and y != 12:
                self.field.append([x,y])
            x += 11
            if x == 441:
                y += 11
                x = 1
--------Method: get_new_indicator, Args: ['self'], Return: None, line 93
        Source:
    def get_new_indicator(self):
        #The length indicator
        self.indicator.append([self.indicator[-1][0] + 11,12])
        #print(len(self.indicator))
--------Method: draw_indicator, Args: ['self', 'window'], Return: None, line 98
        Source:
    def draw_indicator(self,window):
        #Indicator`s painting
        for i in self.indicator:
            pygame.draw.rect(window, (0, 209, 3), pygame.Rect(i[0], i[1], 10, 10))
--------Method: draw_win, Args: ['self', 'window'], Return: None, line 103
        Source:
    def draw_win(self,window):
        #Draws winscreen
        window.blit(self.win, (23,100))
--------Method: draw_lose, Args: ['self', 'window'], Return: None, line 107
        Source:
    def draw_lose(self,window):
        #Draws losescreen
        window.blit(self.lose, (23,100))
--------Method: check_win_lose, Args: ['self'], Return: None, line 111
        Source:
    def check_win_lose(self):
        #Checks game status
        if len(self.indicator) == 0:
            self.game = "LOSE"
        elif len(self.indicator) == 37:
            self.game = "WIN"
--------Method: render, Args: ['self', 'snake', 'window'], Return: None, line 117
        Source:
    def render(self,snake,window):
        font_score = pygame.font.SysFont('Arial', 26, bold=True)
        render_score = font_score.render(f'SCORE: {snake.score}', 1, pygame.Color('red'), (0,0,255))
        window.blit(render_score, (280, 440))

File: indicators_requests.py
----Function: get_indicators, Args: ['indicators', 'name_id', 'territory_type', 'coordinates'], Return: SummaryIndicators, line 11
        Source:
    def get_indicators(
    indicators: list[str],
    name_id: str | int | None = None,
    territory_type: str | None = None,
    coordinates: dict | None = None,
) -> SummaryIndicators:
    # coordinates must be prepared and typed via api.utils.coords_typer.prepare_typed_coords
    if not indicators:
        msg = "Expected at least one indicator"
        raise ValueError(msg)
    if name_id or coordinates:
        json_data = {
            "indicators": indicators,
            "territory_name_id": name_id,
            "territory_type": territory_type,
            "selection_zone": coordinates,
        }
        with Timer() as t:
            response = Api.EndpointsUrban.get_indicators(json_data=json_data)
        logger.info(f"Getting context info time: {t.seconds_from_start} sec")
        return SummaryIndicators.from_dict(response)

    msg = "Expected name_id or coordinates"
    raise ValueError(msg)

File: music.py
----Class: Music, line 2
--------Method: __init__, Args: ['self'], Return: None, line 3
        Source:
    def __init__(self):
        self.now_plays = pygame.mixer.music.load("compositions/tracktwo.mp3")
--------Method: ambient, Args: ['self'], Return: None, line 5
        Source:
    def ambient(self):
        pygame.mixer.music.play(loops=-1)

File: osa_treesitter.py
----Class: OSA_TreeSitter, line 8
--------Method: __init__, Args: ['self', 'scripts_path'], Return: None, line 10
        Source:
    def __init__(self, scripts_path: str):
        self.cwd = scripts_path
        self.script_files = self.files_list(self.cwd)
--------Method: files_list, Args: ['path'], Return: str, line 15
        Source:
    def files_list(path: str) -> str:
        return [file for file in listdir(path) if isfile(join(path, file))]
--------Method: open_file, Args: ['path', 'file'], Return: bytes, line 19
        Source:
    def open_file(path: str, file: str) -> bytes:
        content = None
        with open(os.path.join(path, file), 'rb') as f:
            content = f.read()
        return content
--------Method: _parser_build, Args: ['self', 'filename'], Return: Parser, line 25
        Source:
    def _parser_build(self, filename: str) -> Parser:
        if(filename.endswith(".py")):
            PY_LANGUAGE = Language(tspython.language())
            return Parser(PY_LANGUAGE)
--------Method: _parse_source_code, Args: ['self', 'filename'], Return: None, line 30
        Source:
    def _parse_source_code(self, filename: str):
        parser: Parser = self._parser_build(filename)
        source_code: bytes = self.open_file(self.cwd, filename)
        return parser.parse(source_code), source_code
--------Method: extract_methods, Args: ['self', 'filename'], Return: None, line 35
        Source:
    def extract_methods(self, filename: str):
        structure = []
        tree, source_code = self._parse_source_code(filename)
        root_node = tree.root_node
        for node in root_node.children:
            if node.type == "function_definition":
                method_details = self._extract_function_details(node, source_code)
                start_line = node.start_point[0] + 1 #convert 0-based to 1-based indexing
                structure.append({'type': "function", "start_line": start_line, "details": method_details})

            elif node.type == "class_definition":
                class_name = node.child_by_field_name("name").text.decode("utf-8")
                start_line = node.start_point[0] + 1
                class_methods = []

                for child in node.children:
                    if child.type == "block":
                        method_details = self._traverse_block(child, source_code)
                        for method in method_details:
                            class_methods.append(method)
            
                    if child.type == "function_definition":
                        method_details = self._extract_function_details(child, source_code)
                        class_methods.append(method_details)

                structure.append({"type": "class", "name": class_name, "start_line": start_line, "methods": class_methods})

        return structure
--------Method: _traverse_block, Args: ['self', 'block_node', 'source_code'], Return: None, line 64
        Source:
    def _traverse_block(self, block_node: tree_sitter.Node, source_code: bytes):
        methods = []
        for child in block_node.children:
            if child.type == "function_definition":
                method_details = self._extract_function_details(child, source_code)
                methods.append(method_details)
        return methods
--------Method: _extract_function_details, Args: ['self', 'function_node', 'source_code'], Return: None, line 72
        Source:
    def _extract_function_details(self, function_node: tree_sitter.Node, source_code: bytes):
        method_name = function_node.child_by_field_name("name").text.decode("utf-8")

        parameters_node = function_node.child_by_field_name("parameters")
        arguments = []
        if parameters_node:
            for param_node in parameters_node.children:
                if param_node.type == "identifier":
                    arguments.append(param_node.text.decode("utf-8"))
        
        return_node = function_node.child_by_field_name("return_type")
        return_type = None
        if return_node:
            return_type = source_code[return_node.start_byte:return_node.end_byte].decode("utf-8")
        
        return {
            "method_name": method_name,
            "arguments": arguments,
            "return_type": return_type,
        }
--------Method: analyze_directory, Args: ['self', 'path'], Return: None, line 93
        Source:
    def analyze_directory(self, path: str):
        results = {}
        for filename in self.files_list(path):
            if filename.endswith(".py"):
                structure = self.extract_methods(filename)
                results[filename] = structure
        return results
--------Method: show_results, Args: ['self', 'results'], Return: None, line 101
        Source:
    def show_results(self, results: dict):
        print(f"The provided path: '{self.cwd}'")
        for filename, structures in results.items():
            print(f"File: {filename}")
            for item in structures:
                if item["type"] == "class":
                    print(f"  - Class: {item['name']}")
                    for method in item["methods"]:
                        print(f"      - Method: {method['method_name']}, Args: {method['arguments']}, Return: {method['return_type']}")
                elif item["type"] == "function":
                    details = item["details"]
                    print(f"  - Function: {details['method_name']}, Args: {details['arguments']}, Return: {details['return_type']}")
        print()

File: osa_treesitter1.py
----Class: OSA_TreeSitter, line 8
    Docstring:
    """Class for the extraction of the source code's structure to be processed later by LLM.

    Attributes:
        cwd: A current working directory with source code files.
    """
--------Method: __init__, Args: ['self', 'scripts_path'], Return: None, line 15
        Docstring:
        """Initialization of the instance based on the provided path to the scripts.

        Args:
            scripts_path: provided by user path to the scripts.
        """
        Source:
    def __init__(self, scripts_path: str):
        """Initialization of the instance based on the provided path to the scripts.

        Args:
            scripts_path: provided by user path to the scripts.
        """
        self.cwd = scripts_path
--------Method: files_list, Args: ['path'], Return: None, line 24
        Docstring:
        """Method provides a list of files occuring in the provided path.
        
        If user provided a path to a file with a particular extension
        the method returns a corresponding status which will trigger
        inner "_if_file_handler" method to cut the path's tail.

        Args:
            path: provided by user path to the scripts.

        Returns:
            A tuple containing a list of files in the provided directory
            and status for a specific file usecase. Statuses:
            0 - a directory was provided
            1 - a path to the specific file was provided.
        """
        Source:
    def files_list(path: str):
        """Method provides a list of files occuring in the provided path.
        
        If user provided a path to a file with a particular extension
        the method returns a corresponding status which will trigger
        inner "_if_file_handler" method to cut the path's tail.

        Args:
            path: provided by user path to the scripts.

        Returns:
            A tuple containing a list of files in the provided directory
            and status for a specific file usecase. Statuses:
            0 - a directory was provided
            1 - a path to the specific file was provided.
        """
        try:
            return ([file for file in listdir(path) if isfile(join(path, file))], 0)
        except NotADirectoryError:
            if path.endswith(".py"):
                return ([os.path.basename(os.path.normpath(path))], 1)
--------Method: _if_file_handler, Args: ['cls', 'path'], Return: None, line 47
        Docstring:
        """Inner method returns a path's head if status trigger occured.

        Args:
            path: provided by user path to the scripts.
        
        Returns:
            Path's head.
        """
        Source:
    def _if_file_handler(cls, path: str):
        """Inner method returns a path's head if status trigger occured.

        Args:
            path: provided by user path to the scripts.
        
        Returns:
            Path's head.
        """
        return os.path.split(path)[0]
--------Method: open_file, Args: ['path', 'file'], Return: bytes, line 59
        Docstring:
        """Method reads the content of the occured file.
        
        Args:
            path: provided by user path to the scripts.
            file: file occured in the provided directory.

        Returns:
            Read content.
        """
        Source:
    def open_file(path: str, file: str) -> bytes:
        """Method reads the content of the occured file.
        
        Args:
            path: provided by user path to the scripts.
            file: file occured in the provided directory.

        Returns:
            Read content.
        """
        content = None
        with open(os.path.join(path, file), 'rb') as f:
            content = f.read()
        return content
--------Method: _parser_build, Args: ['self', 'filename'], Return: Parser, line 74
        Docstring:
        """Inner method builds the corresponding parser based on file's extension.

        Args:
            filename: name of the file occured in the provided directory.
        
        Returns:
            Compiled parser.
        """
        Source:
    def _parser_build(self, filename: str) -> Parser:
        """Inner method builds the corresponding parser based on file's extension.

        Args:
            filename: name of the file occured in the provided directory.
        
        Returns:
            Compiled parser.
        """
        if(filename.endswith(".py")):
            PY_LANGUAGE = Language(tspython.language())
            return Parser(PY_LANGUAGE)
--------Method: _parse_source_code, Args: ['self', 'filename'], Return: None, line 87
        Docstring:
        """Inner method parses the provided file with the source code.

        Args:
            filename: name of the file occured in the provided directory.
        
        Returns:
            Tuple containing tree structure of the code and source code.
        """
        Source:
    def _parse_source_code(self, filename: str):
        """Inner method parses the provided file with the source code.

        Args:
            filename: name of the file occured in the provided directory.
        
        Returns:
            Tuple containing tree structure of the code and source code.
        """
        parser: Parser = self._parser_build(filename)
        source_code: bytes = self.open_file(self.cwd, filename)
        return (parser.parse(source_code), source_code)
--------Method: extract_structure, Args: ['self', 'filename'], Return: list, line 100
        Docstring:
        """Method extracts the structure of the occured file in the provided directory.

        Args:
            filename: name of the file occured in the provided directory.

        Returns:
            List containing occuring in file functions, classes, their start lines and methods
        """
        Source:
    def extract_structure(self, filename: str) -> list:
        """Method extracts the structure of the occured file in the provided directory.

        Args:
            filename: name of the file occured in the provided directory.

        Returns:
            List containing occuring in file functions, classes, their start lines and methods
        """
        structure = []
        tree, source_code = self._parse_source_code(filename)
        root_node = tree.root_node
        for node in root_node.children:
            if node.type == "function_definition":
                method_details = self._extract_function_details(node, source_code)
                start_line = node.start_point[0] + 1 #convert 0-based to 1-based indexing
                structure.append({'type': "function", "start_line": start_line, "details": method_details})

            elif node.type == "class_definition":
                class_name = node.child_by_field_name("name").text.decode("utf-8")
                start_line = node.start_point[0] + 1
                class_methods = []

                for child in node.children:
                    if child.type == "block":
                        method_details = self._traverse_block(child, source_code)
                        for method in method_details:
                            class_methods.append(method)
            
                    if child.type == "function_definition":
                        method_details = self._extract_function_details(child, source_code)
                        class_methods.append(method_details)

                structure.append({"type": "class", "name": class_name, "start_line": start_line, "methods": class_methods})

        return structure
--------Method: _traverse_block, Args: ['self', 'block_node', 'source_code'], Return: list, line 137
        Docstring:
        """Inner method traverses occuring in file's tree structure "block" node.

        Args:
            block_node: an occured block node, containing class's methods.
            source_code: source code of the file in bytes.
        
        Returns:
            List of function/method's details.
        """
        Source:
    def _traverse_block(self, block_node: tree_sitter.Node, source_code: bytes) -> list:
        """Inner method traverses occuring in file's tree structure "block" node.

        Args:
            block_node: an occured block node, containing class's methods.
            source_code: source code of the file in bytes.
        
        Returns:
            List of function/method's details.
        """
        methods = []
        for child in block_node.children:
            if child.type == "decorated_definition":
                for dec_child in child.children:
                    if dec_child.type == "function_definition":
                        method_details = self._extract_function_details(dec_child, source_code)
                        methods.append(method_details)

            if child.type == "function_definition":
                method_details = self._extract_function_details(child, source_code)
                methods.append(method_details)
        return methods
--------Method: _extract_function_details, Args: ['self', 'function_node', 'source_code'], Return: dict, line 160
        Docstring:
        """Inner method extracts the details of "function_definition" node in file's tree structure.

        Args:
            function_node: an occured block node, containing class's methods details.
            source_code: source code of the file in bytes.
        
        Returns:
            Dictionary containing method's/function's name, args, return type, start line 
            and source code.
        """
        Source:
    def _extract_function_details(self, function_node: tree_sitter.Node, source_code: bytes) -> dict:
        """Inner method extracts the details of "function_definition" node in file's tree structure.

        Args:
            function_node: an occured block node, containing class's methods details.
            source_code: source code of the file in bytes.
        
        Returns:
            Dictionary containing method's/function's name, args, return type, start line 
            and source code.
        """
        method_name = function_node.child_by_field_name("name").text.decode("utf-8")
        start_line = function_node.start_point[0] + 1
        parameters_node = function_node.child_by_field_name("parameters")
        arguments = []
        if parameters_node:
            for param_node in parameters_node.children:
                if param_node.type == "typed_parameter":
                    for typed_param_node in param_node.children:
                        if typed_param_node.type == "identifier":
                            arguments.append(typed_param_node.text.decode("utf-8"))
                if param_node.type == "typed_default_parameter":
                    for typed_param_node in param_node.children:
                        if typed_param_node.type == "identifier":
                            arguments.append(typed_param_node.text.decode("utf-8"))
                if param_node.type == "identifier":
                    arguments.append(param_node.text.decode("utf-8"))
        
        source_code_start = function_node.start_byte
        source_code_end = function_node.end_byte
        source = source_code[source_code_start:source_code_end].decode("utf-8")

        return_node = function_node.child_by_field_name("return_type")
        return_type = None
        if return_node:
            return_type = source_code[return_node.start_byte:return_node.end_byte].decode("utf-8")
        
        return {
            "method_name": method_name,
            "arguments": arguments,
            "return_type": return_type,
            "start_line": start_line,
            "source_code": source,
        }
--------Method: analyze_directory, Args: ['self', 'path'], Return: dict, line 205
        Docstring:
        """Method analyzes provided directory.

        Args:
            path: provided by user path to the scripts.

        Returns:
            Dictionary containing a filename and its source code's structure.
        """
        Source:
    def analyze_directory(self, path: str) -> dict:
        """Method analyzes provided directory.

        Args:
            path: provided by user path to the scripts.

        Returns:
            Dictionary containing a filename and its source code's structure.
        """
        results = {}
        files_list, status = self.files_list(path)
        if status:
            self.cwd = OSA_TreeSitter._if_file_handler(path)
        for filename in files_list:
            if filename.endswith(".py"):
                structure = self.extract_structure(filename)
                results[filename] = structure
        return results
--------Method: show_results, Args: ['self', 'results'], Return: None, line 224
        Docstring:
        """Method prints out the results of the directory analyze.

        Args:
            results: dictionary containing a filename and its source code's structure.
        """
        Source:
    def show_results(self, results: dict):
        """Method prints out the results of the directory analyze.

        Args:
            results: dictionary containing a filename and its source code's structure.
        """
        print(f"The provided path: '{self.cwd}'")
        for filename, structures in results.items():
            print(f"File: {filename}")
            for item in structures:
                if item["type"] == "class":
                    print(f"  - Class: {item['name']}, line {item['start_line']}")
                    for method in item["methods"]:
                        print(f"      - Method: {method['method_name']}, Args: {method['arguments']}, Return: {method['return_type']}, line {method['start_line']}")
                        print(f"        Source:\n{method['source_code']}")
                elif item["type"] == "function":
                    details = item["details"]
                    print(f"  - Function: {details['method_name']}, Args: {details['arguments']}, Return: {details['return_type']}, line {details['start_line']}")
                    print(f"        Source:\n{details['source_code']}")
        print()
--------Method: log_results, Args: ['self', 'results'], Return: None, line 245
        Docstring:
        """Method logs the results of the directory analyze into "examples/report.txt".

        Args:
            results: dictionary containing a filename and its source code's structure.
        """
        Source:
    def log_results(self, results: dict):
        """Method logs the results of the directory analyze into "examples/report.txt".

        Args:
            results: dictionary containing a filename and its source code's structure.
        """
        os.makedirs("examples",exist_ok = True)
        with open("examples/report.txt", 'w') as f:
            f.write(f"The provided path: '{self.cwd}'\n")
            for filename, structures in results.items():
                f.write(f"File: {filename}\n")
                for item in structures:
                    if item["type"] == "class":
                        f.write(f"  - Class: {item['name']}, line {item['start_line']}\n")
                        for method in item["methods"]:
                            f.write(f"      - Method: {method['method_name']}, Args: {method['arguments']}, Return: {method['return_type']}, line {method['start_line']}\n")
                            f.write(f"        Source:\n{method['source_code']}\n")
                    elif item["type"] == "function":
                        details = item["details"]
                        f.write(f"  - Function: {details['method_name']}, Args: {details['arguments']}, Return: {details['return_type']}, line {details['start_line']}\n")
                        f.write(f"        Source:\n{method['source_code']}\n")
                f.write("\n")

File: snake.py
----Class: Snake, line 2
--------Method: __init__, Args: ['self'], Return: None, line 3
        Source:
    def __init__(self):
        self.score = 0
        self.head = [45,45]
        self.body = [[45,45],[34,45],[23,45]]
--------Method: moove, Args: ['self', 'control'], Return: None, line 7
        Source:
    def moove(self,control):
        if control.flag_direction == "RIGHT":
            self.head[0] += 11
        if control.flag_direction == "LEFT":
            self.head[0] -= 11
        if control.flag_direction == "DOWN":
            self.head[1] += 11
        if control.flag_direction == "UP":
            self.head[1] -= 11
--------Method: animation, Args: ['self'], Return: None, line 17
        Source:
    def animation(self):
        #Head ahead and tail gets back
        self.body.insert(0,list(self.head))
        self.body.pop()
--------Method: draw_snake, Args: ['self', 'window'], Return: None, line 22
        Source:
    def draw_snake(self,window):
        for segment in self.body:
            pygame.draw.rect(window, (0, 209, 3), pygame.Rect(segment[0], segment[1], 10, 10))
--------Method: check_end_window, Args: ['self'], Return: None, line 26
        Source:
    def check_end_window(self):
        #Checking if snake reached the level`s edge
        if self.head[0] == 419:
            self.head[0] = 23
        elif self.head[0] == 12:
            self.head[0] = 419
        elif self.head[1] == 23:
            self.head[1] = 419
        elif self.head[1] == 419:
            self.head[1] = 34
--------Method: eat, Args: ['self', 'food', 'gui'], Return: None, line 38
        Source:
    def eat(self,food,gui):
        #Snake eating
        if self.head == food.food_position:
            self.body.append(food.food_position)
            food.get_food_position(gui)
            gui.get_new_indicator()
--------Method: check_barrier, Args: ['self', 'gui'], Return: None, line 45
        Source:
    def check_barrier(self,gui):
        #Be careful with barriers!
        if self.head in gui.barrier:
            self.body.pop()
            gui.indicator.pop()
            #print(len(gui.indicator))
            #print(gui.game)

        if self.head in self.body[1:]:
            self.body.pop()
            gui.indicator.pop()
            #print(len(gui.indicator))
            #print(gui.game)
--------Method: count_score, Args: ['self', 'food', 'gui'], Return: None, line 58
        Source:
    def count_score(self,food,gui):
        if self.head == food.food_position:
            self.score += 10
        elif self.head in gui.barrier or self.head in self.body[1:]:
            self.score -= 10

File: summary_tables_requests.py
----Function: get_summary_table, Args: ['table', 'name_id', 'territory_type', 'coordinates'], Return: SummaryTable, line 8
        Source:
    def get_summary_table(
    table: str,
    name_id: str | None = None,
    territory_type: str | None = None,
    coordinates: list = None,
) -> SummaryTable:
    if name_id:
        data = Api.EndpointsUrban.get_summary_table(
            table=table,
            territory_name_id=name_id,
            territory_type=territory_type,
            selection_zone=None,
        )
        return SummaryTable.from_dict(data)
    elif coordinates:
        data = Api.EndpointsUrban.get_summary_table(
            table=table,
            territory_name_id=None,
            territory_type=None,
            selection_zone=coordinates,
        )
        return SummaryTable.from_dict(data)
    else:
        raise ValueError("Expected name_id and type or coordinates or just name_id")

